# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature handles
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# onewayHandles provide a means to create handles that refer to update-able
# cells using a one-way monad.
#
# onewayHandles is a one-way state monad. It provides features to create
# several handles that refer to modifiable value and features to 'get', 'put'
# or 'update' this value.
#
# This monad is fully functional, it does not mutate data but creates a long
# sequence to remember updates
#
# NYI: handling of one-way monads is completely experimental
#
private onewayHandles<T,X>(
  # the inner value of this monad
  v X,
  n i32,
  s Sequence<tuple<i32,T>>,
  redef r plain | inst | repl
  ) : onewayMonad r
is

  # create a new instance with one additional handle
  #
  # the new handle can be accessed by 'result.last'
  #
  new (
    # initial value refered to by the new handle
    w T
    ) onewayHandles<T,X>
  post
    result.hasLast
  is
    onewayHandles<T,X> v n+1 ([(n,w)] ++ s) mode


  # has one element been created using 'new'?
  #
  hasLast => n > 0


  # return the last handle that was created by 'new'
  #
  last
    pre
      hasLast
   =>
    onewayHandle n-1


  # a one-way feature to create a new handle and update the monad
  # in the current environment
  #
  #
  /* env */
  create (
    # initial value refered to by the new handle
    w T
    )
   =>
    (new w).last


  # get the value refered to by a given handle
  #
  get (
    # a handle created by 'new'
    h onewayHandle/*<T>*/
    ) /* one way! */
   =>
    for x in s
    until x.values.0 == h.x
      x.values.1
    else
      fuzion.std.panic "no entry for {h.x} found"


  # create a new instance with new value refered to by a given handle
  #
  put (
    # a handle created by 'new'
    h onewayHandle/*<T>*/,

    # the new value to be stored with 'h'
    w T)
   =>
    onewayHandles<T,X> v n ([(h.x,w)] ++ s) mode


  # create a new instance with the value refered to by a given handle read and
  # updated.
  #
  update (
    # a handle created by 'new'
    h onewayHandle/*<T>*/,

    # function calculcating the new value from the old value
    f T->T
    )
   =>
    for x in s
    until x.values.0 == h.x
      onewayHandles<T,X> v n ([(h.x,f x.values.1)] ++ s) mode
    else
      fuzion.std.panic "no entry for {h.x} found"


  infix >>= (f X -> onewayHandles<T,X>) => bind<X> f

  bind <B> (f X -> onewayHandles<T,B>) onewayHandles<T,B> is
    onewayHandles<T,B> (f v).v n s plain

  return<B> (w B) => onewayHandles<T,B> w n s plain


# short-hand for creating an empty set of handles of given type.
#
onewayHandles<T>(rr ()->unit) =>
  onewayHandles<T,unit> unit 0 Sequences.empty<tuple<i32,T>> (inst rr)
  unit

# short-hand for creating an empty set of handles of given type.
#
onewayHandles<T> =>
  onewayHandles<T,unit> unit 0 Sequences.empty<tuple<i32,T>> plain

# handle value created by 'handles.new'
#
private onewayHandle (
  private x i32
  )
is
