# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa GmbH, Berlin
#
#  Source code of Fuzion standard library feature streamable
#
#  Author: Fridtjof Siebert (siebert@tokiwa.eu)
#
# -----------------------------------------------------------------------

# streamable -- ancestor for features that can be converted to a stream
#
streamable<T> ref : hasList<T> is


  # create a stream of T
  #
  asStream stream<T> is abstract


  # create a list from this streamable
  #
  asList => asStream.asList


  # count the elements of stream created from this streamable
  #
  count => asStream.count


  # collect the contents of this streamable into an array
  #
  asArray array<T> is
    s := asStream
    array<T> count, fun (i i32) => s.next


  # create a stream and call 'forAll f' on it
  #
  forAll(f fun (T)) unit is asStream.forAll f


  # create a stream and have it consumed by f, infix operator synonyme of forAll.
  #
  infix | (f fun (T)) => forAll f


  # create a stream, infix operator synonyme for asStream
  #
  postfix | => asStream


  # create a new stream and apply 'f' to each element 'e' as long as 'f e'
  #
  forWhile(f fun (T) bool) is asStream.forWhile f


  # create a new stream that contains the first elements of this stream for
  # which 'f e' is false
  #
  before(f fun (T) bool) stream<T> is asStream.before f


  # create a new stream and filter its elements using predicate f
  #
  filter   (f fun (T) bool) stream<T> is asStream.filter f


  # create a new stream and filter its elements using predicate f, infix operator
  # synonyme of filter.
  #
  infix |& (f fun (T) bool) => filter f


  # create a new stream and filter its elements using predicate f, infix operator
  # synonyme of filter.
  #
  # NYI: What is better, 'infix |&' or 'infix &', or something else?
  #
  infix & (f fun (T) bool) => filter f


  # create a stream and check if predicate f holds for all elements produced
  #
  infix ∀ (f fun (T) bool) bool is asStream ∀ f


  # create a stream and check if predicate f holds for at least one element produced
  #
  infix ∃ (f fun (T) bool) bool is asStream ∃ f


  # create a streamable that consists only of the first n elements of this
  # streamable, fewer if this stream has fewer elements
  #
  take (n i32) ref : streamable<T> is
        asStream stream<T> is
          ref : stream<T> {
              s := streamable.this.asStream
              remaining := n
              hasNext => remaining > 0 && s.hasNext
              next => set remaining := remaining - 1; s.next
            }


  # create a streamable that consists of the elements of this stream except the first
  # n elements
  #
  drop (n i32) ref : streamable<T> is
    asStream =>
      s := streamable.this.asStream
      for _ in 1..n while s.hasNext
        s.next
      s


  # create a slice from this streamable that consists of the elements starting at index
  # from (including) up to index to (excluding).
  #
  slice(from, to i32) streamable<T> is
    drop(from).take to-from
    # NYI: OPTIMIZATION: We could redefine this, e.g. for to avoid copying array data
    # on array.slice(from,to).asArray.


  # create a streamable that consists of all be the elements if this stream followed
  # by all the elements of s
  #
  concatStreamables (s streamable<T>) ref : streamable<T> is
    asStream stream<T> is
      st : stream<T> is
        s1 := streamable.this.asStream
        s2 := s.asStream
        hasNext => s1.hasNext || s2.hasNext
        next => if (s1.hasNext) s1.next else s2.next
      st


  # infix operand synonyme for concatSteramables
  #
  infix ++ (s streamable<T>) streamable<T> is concatStreamables s


  # create a stream and then create a string from the elements of that stream
  #
  redef asString => asStream.asString


  # map the stream to a new stream applying function f to all elements
  #
  # This performs a lazy mapping, f is called only when the elements
  # are taken from the stream.
  #
  # NYI: As long as covariance for result type is not permitted we cannt
  # call this 'map' since this would clash with, e.g., 'array.map'
  #
  mapStreamable<B>(f fun(T) B) streamable<B> is
    ref : streamable<B> {
        asStream =>
          ref : stream<B> {
              s := streamable.this.asStream
              hasNext => s.hasNext
              next => f s.next
            }
      }


  # fold the elements of this streamable using the given monoid.
  #
  # e.g., to sum the elements of a stream of i32, use s.fold i32.sum
  #
  fold (m Monoid<T>) => asStream.fold m.e, m
