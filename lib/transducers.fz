# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature Sequence
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# transducers map one reducing function to another
#
# see https://clojure.org/reference/transducers
# for in depth information about transducers
#
# usage example:
#
# human(age i32) is
# ages := map<i32, human, i32> (x -> x.age)
# gt_ten := filter<i32, i32> (x -> x > 10)
# xf := ages ° gt_ten ° count<i32>
# res := [human(4), human(12), human(30)].apply xf 0
# say res # expected output is 2
transducers is

  # filter values based on evaluation of predicate
  filter<R,T>(predicate T -> bool) ref transducer<R,R,T,T> is
    ref : transducer<R,R,T,T>
      redef call(red reducing_fn<R,T>) ref reducing_fn<R,T> is
        ref : reducing_fn<R,T>
          redef call(res R, val T) R is
            if predicate val then red.call res val else res


  # map values from T to U
  map<R,T,U>(mapper T -> U) ref transducer<R,R,T,U> is
    ref : transducer<R,R,T,U>
      redef call(red reducing_fn<R,U>) ref reducing_fn<R,T> is
        ref : reducing_fn<R,T>
          redef call(res R, val T) R is
            red.call res (mapper val)


  # count amount of values
  count<T>() ref transducer<i32,i32,T,i32> is
    ref : transducer<i32,i32,T,i32>
      redef call(red reducing_fn<i32,i32>) ref reducing_fn<i32,T> is
        ref : reducing_fn<i32,T>
          redef call(res i32, val T) i32 is
            res + 1



reducing_fn<RR, T> ref : Function<RR,RR,T> is
  redef call(res RR, val T) RR is abstract

transducer<R1, R2, T, U> ref : Function<reducing_fn<R1,T>, reducing_fn<R2,U>> is
  redef call(red reducing_fn<R2,U>) reducing_fn<R1,T> is abstract

  # compose NYI not needed if Function provides composition
  infix ° <R3,V>(o transducer<R2,R3,U,V>) transducer<R1,R3,T,V> is
    ref : transducer<R1,R3,T,V>
      redef call(re reducing_fn<R3,V>) ref reducing_fn<R1,T> is
        a := (o.call re)
        transducer.this.call a
