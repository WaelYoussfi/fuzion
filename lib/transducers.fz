# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature Sequence
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# transducers map one reducing function to another
#
# see https://clojure.org/reference/transducers
# for in depth information about transducers
#
# usage example:
#
# human(age i32) is
# ages := map (Sequence i32) human i32 (x -> x.age)
# gt_ten := filter (Sequence i32) i32 (x -> x > 10)
# xf := ages ∘ gt_ten
# say ([human(4), human(12), human(30)].into xf) # [12,30]
transducers is

  # a transducer filtering values based on evaluation of predicate
  filter(TA,T type, predicate T -> bool) Transducer(TA,T,T) is
    ref : Transducer(TA,T,T)
      call(red Reducing_Fn(TA,T)) =>
        ref : Reducing_Fn(TA,T)
          call(res TA, val T) =>
            if predicate val then red.call res val else res


  # a transducer mappping values from T to U
  map(TA,T,U type, mapper T -> U) Transducer(TA,U,T) is
    ref : Transducer(TA,U,T)
      call(red Reducing_Fn(TA,U)) =>
        ref : Reducing_Fn(TA,T)
          call(res TA, val T) =>
            red.call res (mapper val)


  # left-to-right composition of transducers
  compose(TA,A,B,C type, a Transducer(TA,B,C), b Transducer(TA,A,B)) =>
    a ∘ b

  # NYI: cat, mapcat, remove, take, takeWhile, drop, dropWhile, takeEveryNth,
  # replace, keep, keepIndexed, dedupe, randomSample, partitionBy, partitionAll,...

# a reducing function takes a previous result and a value and returns a new result
Reducing_Fn(TA,T type) ref : Function<TA,TA,T> is

    # NYI redef call abstract is currently necessary because of bug in c backend
    redef call(res TA, val T) TA is abstract

# TA result     type
# B    input      type
# C    transduced type
Transducer(TA,B,C type) ref : Function(Reducing_Fn(TA,C), Reducing_Fn(TA,B)) is

  # NYI redef call abstract is currently necessary because of bug in c backend
  redef call(rf Reducing_Fn(TA,B)) Reducing_Fn(TA,C) is abstract
  # left-to-right composition of transducers
  infix ∘ (A type, o Transducer(TA,A,B)) =>
    ref : Transducer(TA,A,C)
      redef call(re Reducing_Fn(TA,A)) =>
        Transducer.this.call (o.call re)
