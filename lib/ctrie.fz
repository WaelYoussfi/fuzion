# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature CTrie
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# A Fuzion implementation of CTrie invented by Aleksandar Prokopec
# CTrie is a non-blocking concurrent hash trie
#
# reference paper: Concurrent Tries with Efficient Non-Blocking Snapshots
# https://aleksandar-prokopec.com/resources/docs/ctries-snapshot.pdf
#
# reference implementation in Scala: https://github.com/axel22/Ctries/
# on wikipedia: https://en.wikipedia.org/wiki/Ctrie
#
# Complexity (according to the paper):
# insert, lookup, remove                     : O(log n)
# snapshot, amortized size retrieval, clear  : O(1)
#
# NYI (atomic) CAS
# NYI gen handling
# NYI snapshots
#
# glossary:
# CTK => ctrie key
# CTV => ctrie value
# k   => key
# v   => value
# gen => generation
# lev => level
# bmp => bitmap
# idx => index
# W   => 2^W-way branching factor
#
CTrie<CTK: hasHash<CTK>, CTV> : map<CTK, CTV> is

  # a tomb node
  # "a T-node is the last value assigned to an I-node"
  private TNode(sn SNode) is
    redef asString => "TNode($sn)"

    asList => sn.asList


  # a singleton node
  private SNode(k CTK, v CTV) is
    redef asString => "SNode($k, $v)"

    asList => [(k,v)].asList


  # an i or a singleton node
  private Branch: choice<INode,SNode> is
    redef asString =>
      match Branch.this
        iNode INode => "$iNode"
        sNode SNode => "$sNode"

    asList =>
      match Branch.this
        iNode INode => iNode.asList
        sNode SNode => sNode.asList


  # a container node
  private CNode(bmp u32, array array<Branch>) is
    updated(pos u32, node Branch) =>
      CNode bmp (array.put pos.as_i32 node)

    inserted(pos, flag u32, sn SNode) =>
      CNode (bmp | flag) (array.insert pos.as_i32 sn).asArray

    removed(pos, flag u32) =>
      # NYI delete/remove should be in stdlib
      tmp := array.take pos.as_i32 ++ array.drop (pos + 1).as_i32
      CNode (bmp ^ flag) tmp.asArray

    redef asString => "CNode($bmp, [{array.map<string>(x -> x.asString).fold (strings.concat ", ")}])"

    asList => array.flatMapSequence<tuple<CTK,CTV>>(b -> b.asList).asList


  # a container, T or linked list node
  # NYI should inhert from choice but nesting of choices leads to bugs currently
  private MainNode(data choice<CNode,TNode,LNode>, gen i32) : hasEquals<MainNode> is
    redef asString =>
      match data
        cNode CNode => "$cNode"
        tNode TNode => "$tNode"
        lNode LNode => "$lNode"

    infix = (o MainNode) bool is
      match data
        thiz CNode =>
          match o.data
            that CNode => false # thiz = that
            * => false
        thiz TNode =>
          match o.data
            that TNode => false # thiz = that
            * => false
        thiz LNode =>
          match o.data
            that TNode => false # thiz = that
            * => false

    asList =>
      match data
        cNode CNode => cNode.asList
        tNode TNode => tNode.asList
        lNode LNode => lNode.mapSequence<tuple<CTK,CTV>>(sn -> (sn.k, sn.v))


    prev option<INode> := nil
    set_prev(m option<INode>) unit is
      set prev := m


  # failed node
  FNode(prev INode) is

  # an indirection node
  private INode(data choice<MainNode,FNode,nil>) ref is

    gen i32 is
      match data
        m MainNode => m.gen
        f FNode => f.prev.gen
        nil => fuzion.std.panic "illegal state, tried getting gen, on empty INode."

    get_main MainNode is
      match data
        m MainNode => m
        * => fuzion.std.panic "illegal state, tried getting main node, when there is none."

    # compare and set
    private CAS(old_n choice<MainNode,FNode,nil>, new_n choice<MainNode,FNode,nil>) bool is
      # NYI this must be atomic
      # if(main.hash != old_n.hash)
      #   false
      # else
      set data := new_n
      true

    GCAS_Commit(m INode, ct ref CTrie<CTK,CTV>) INode is
      prev := m.get_main.prev
      ctr := ct.RDCSS_READ_ROOT(true)
      match prev
        nil => m
        i INode =>
          match i.data
            nil => fuzion.std.panic "illegal state, previous node should have failed or main node."
            fn FNode =>
              if CAS m.data fn.prev.data
                fn.prev
              else
                # NYI do we need to copy inode here?
                GCAS_Commit INode.this ct
            n MainNode =>
              if ctr.gen = gen && ct.nonReadOnly
                if m.CAS n nil
                  m
                else
                  GCAS_Commit m ct
              else
                m.CAS n (FNode (INode n))
                GCAS_Commit i ct


    # NYI should not be ref?
    GCAS_READ(ct ref CTrie<CTK, CTV>) MainNode is
      m := get_main
      match m.prev
        nil => m
        * => (GCAS_Commit (INode data) ct).get_main

    GCAS(o INode, n MainNode, ct CTrie<CTK, CTV>) =>
      n.set_prev o
      if(CAS o.data n)
        GCAS_Commit INode.this ct
        match n.prev
          nil => true
          * => false
      else
        false

    redef asString => "INode($data, $gen)"

    asList list<tuple<CTK, CTV>> is
      match data
        m MainNode => m.asList
        * => fuzion.std.panic "illegal state, tried calling asList for failed or empty nodes."

  nonReadOnly := true

  CAS_ROOT(ov, nv choice<INode, RDCSS_Descriptor>) =>
    true
    # NYI CAS root

  RDCSS_Complete(abort bool) INode is
    match root
      n INode => n
      desc RDCSS_Descriptor =>
        if abort
          if CAS_ROOT desc desc.ov
            desc.ov
          else
            RDCSS_Complete abort
        else
          old_main := desc.ov.GCAS_READ CTrie.this
          if old_main = desc.exp
            if CAS_ROOT desc desc.nv
              desc.set_committed
              desc.nv
            else
              RDCSS_Complete abort
          else
            if CAS_ROOT desc desc.ov
              desc.ov
            else
              RDCSS_Complete abort

  RDCSS_READ_ROOT(abort bool) INode is
    match root
      n INode => n
      d RDCSS_Descriptor => RDCSS_Complete abort

  RDCSS_READ_ROOT() => RDCSS_READ_ROOT false

  RDCSS_Descriptor(ov INode, exp MainNode, nv INode) is
    committed := false

    set_committed =>
      set committed := true

  LNode(from Sequence<SNode>) : Sequence<SNode> is
    redef asList => from.asList


  private RESTART is
  private OK is
  NOTFOUND is
    redef asString => "not found"

  # 2^5 = 32
  private W := u32 5
  private root choice<INode, RDCSS_Descriptor> := INode (MainNode (CNode 0 []) 0)


  private hash(h u64) u32 is
    h.hash.as_u32


  private flagpos(hash u32, lev u32, bmp u32) tuple<u32, u32> is
    idx := (hash >> lev) & 0x1F
    flag := u32 1 << idx
    mask := flag -Â° 1
    pos := (bmp & mask).onesCount.as_u32
    (flag, pos)


  private toCompressed(cn CNode, lev u32, gen i32) =>
    narr := cn.array.map<Branch> (n -> match n
                                         m INode =>
                                           match m.get_main.data
                                             // resurrect
                                             tn TNode => tn.sn
                                             * => m
                                         sn SNode => sn
                                    )
    toContracted (CNode cn.bmp narr) lev gen


  private toContracted(cn CNode, lev u32, gen i32) MainNode is
    if (lev > 0) & (cn.array.length = 1)
      match cn.array[0]
        sn SNode => MainNode (TNode sn) gen
        i INode => MainNode cn gen
    else
      MainNode cn gen


  private clean(nd option<INode>, lev u32, gen i32) =>
    if nd??
      m := nd.get.get_main
      match m.data
        c CNode => nd.get.CAS(m, (toCompressed c lev gen))
        * =>
    unit


  private cleanParent(parent option<INode>, i INode, hash, lev u32, gen i32) =>
    parent >>= (p ->
      m := p.get_main
      match m.data
        cn CNode =>
          (flag, pos) := flagpos hash lev cn.bmp
          if (cn.bmp & flag) != 0
            sub := cn.array[pos.as_i32]
            match sub
              iNode INode =>
                # NYI is same object?
                if iNode.hashCode = i.hashCode
                  match i.get_main.data
                    tn TNode =>
                      ncn := cn.updated pos tn.sn
                      if !(p.CAS m (toContracted ncn lev gen))
                        cleanParent p i hash lev gen
                    * =>
              * =>
        * =>
      nil
      )


  private dual(x, y SNode, lev u32, gen i32) MainNode is
    # NYI why 35??
    if lev < 35
      xidx := ((hash x.k.hash) >> lev) & 0x1f
      yidx := ((hash y.k.hash) >> lev) & 0x1f
      bmp := (u32 1 << xidx) | (u32 1 << yidx)
      if xidx = yidx
        subinode := INode (dual x y (lev + W) gen)
        MainNode (CNode bmp [subinode]) gen
      else
        if (xidx < yidx)
          MainNode (CNode bmp [x, y]) gen
        else
          MainNode (CNode bmp [y, x]) gen
    else
      MainNode (LNode [(SNode x.k x.v), (SNode y.k y.v)]) gen


  # lookup key k
  lookup(k CTK) option<CTV> is
    r := RDCSS_READ_ROOT
    res := ilookup r k 0 nil r.gen
    match res
      r RESTART =>
        lookup k
      NOTFOUND =>
        nil
      v CTV =>
        v


  private ilookup(i INode, k CTK, lev u32, parent option<INode>, gen i32) choice<RESTART,NOTFOUND,CTV> is
    m := i.GCAS_READ CTrie.this
    match m.data
      cn CNode =>
        (flag, pos) := flagpos (hash k.hash) lev cn.bmp
        if (cn.bmp & flag) = 0
          NOTFOUND
        else
          match cn.array[pos.as_i32]
            sin INode =>
              ilookup sin k (lev + W) i gen
            sn SNode =>
              if sn.k = k
                sn.v
              else
                NOTFOUND
      tn TNode =>
        clean parent (lev - W) gen
        RESTART
      ln LNode => find ln k


  private find(ln LNode, k CTK) choice<RESTART, NOTFOUND, CTV> is
    match ln.dropWhile(sn -> sn.k /= k).head
          nil => NOTFOUND
          sn SNode => sn.v


  # add key value
  # if key is already present value is updated
  add(k CTK, v CTV) unit is
    r := RDCSS_READ_ROOT
    match iinsert r k v 0 nil r.gen
      r RESTART =>
        add k v
      OK =>
        unit


  private iinsert(i INode, k CTK, v CTV, lev u32, parent option<INode>, gen i32) choice<RESTART,OK> is
    m := i.GCAS_READ CTrie.this
    match m.data
      cn CNode =>
        (flag, pos) := flagpos (hash k.hash) lev cn.bmp
        if (cn.bmp & flag) = 0
          ncn := cn.inserted pos flag (SNode k v)
          if i.CAS m (MainNode ncn gen)
            OK
          else
            RESTART
        else
          match cn.array[pos.as_i32]
            sin INode =>
              iinsert sin k v (lev+W) i gen
            sn SNode =>
              if sn.k /= k
                nin := INode (dual sn (SNode k v) (lev + W) i.gen)
                ncn := cn.updated pos nin
                if i.CAS m (MainNode ncn gen)
                  OK
                else
                  RESTART
              else
                ncn := cn.updated pos (SNode k v)
                if i.CAS m (MainNode ncn gen)
                  OK
                else
                  RESTART
      tn TNode =>
        clean parent (lev - W) gen
        RESTART
      ln LNode =>
        if i.CAS m (MainNode (LNode ([SNode k v] ++ ln)) i.gen)
          OK
        else
          RESTART


  remove(k CTK) choice<NOTFOUND, CTV> is
    r := RDCSS_READ_ROOT
    match iremove r k 0 nil r.gen
      r RESTART => remove k
      n NOTFOUND => n
      v CTV => v


  private iremove(i INode, k CTK, lev u32, parent option<INode>, gen i32) choice<RESTART, NOTFOUND, CTV> is
    m := (i.GCAS_READ CTrie.this)
    match m.data
      cn CNode =>
        (flag, pos) := flagpos (hash k.hash) lev cn.bmp
        if (cn.bmp & flag) = 0
          NOTFOUND
        else
          res choice<RESTART, NOTFOUND, CTV> := match cn.array[pos.as_i32]
            sin INode =>
              iremove sin k (lev + W) i gen
            sn SNode =>
              if sn.k /= k
                NOTFOUND
              else
                ncn  := cn.removed pos flag
                cntr := toContracted ncn lev gen
                if i.CAS m cntr
                  sn.v
                else
                  RESTART
          match res
            v CTV =>
              match (i.get_main).data
                t TNode => cleanParent parent i hash(k.hash) (lev - W) gen
                * =>
            * =>
          res
      tn TNode =>
        clean parent (lev - W) gen
        RESTART
      ln LNode =>
        fln := LNode ln.filter(sn -> sn.k /= k)
        nln MainNode := if fln.count = 1 then MainNode (TNode fln.first) i.gen else MainNode fln i.gen
        if i.CAS m nln
          find ln k
        else
          RESTART


  redef size i32 is
    items.count


  redef index [] (k CTK) option<CTV> is
    lookup k


  redef items Sequence<tuple<CTK,CTV>> is
    # NYI take snapshot
    RDCSS_READ_ROOT.asList
