# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test FloatingPointNumbers
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

floating_point_numbers is

  exitCode := 0

  chck(b bool, msg string) =>
    s := if b
      "PASSED: "
    else
      set exitCode := 1
      "FAILED: "
    say (s + msg)

  duplicate<T:float<T>>(f T) =>
    f + f

  threefold<T:float<T>>(f T) =>
    f + f + f

  generic_tests<T: float<T>>(a T) is
    # serialize floating point numbers
    # NYI serialization will be done in fuzion and then we won't have
    # different results for interpreter- / c- backend
    chck ("{a.quietNaN}" ==  "nan" || "{a.quietNaN}" ==  "NaN")     "{a.name}: quiet nan serializes correctly"
    chck ("{a.negativeInfinity}"
      .replace("I", "i")
      .substring(0, 4) ==  "-inf")                                  "{a.name}: neg inf serializes correctly"
    chck ("{a.positiveInfinity}"
      .replace("I", "i")
      .substring(0, 3) ==  "inf")                                   "{a.name}: pos inf serializes correctly"
    chck ("{a.zero}".startsWith "0")                                "{a.name}: 0 serializes to string"
    chck ("{-a.zero}".startsWith "-0")                              "{a.name}: -0 serializes to string"
    chck ("{a.one}".startsWith "1")                                 "{a.name}: 1 serializes to string"
    chck ("{a.one / (duplicate a.one)}" == "0.5")                   "{a.name}: 0.5 serializes to string"
    chck ("{a.one / (threefold a.one)}".startsWith "0.3333333")     "{a.name}: 1/3 serializes to string"

    # comparision operators
    chck (
      a.zero == a.zero &&
      a.zero != a.one &&
      a.one  >= a.zero &&
      a.zero <= a.one &&
      a.zero == a.zero &&
      a.one  >  a.zero &&
      a.zero <  a.one)                                              "{a.name}: comparison operators work as expected"

    # negation operator
    chck ((-(-a.zero) == a.zero) &&
          (-(-a.one) == a.one) &&
          (-(-a.positiveInfinity) == a.positiveInfinity) &&
          (-(-a.negativeInfinity) == a.negativeInfinity))          "{a.name}: double negation is same number"

    # operator +,-,*,/ test
    chck (a.zero + a.one == a.one)                                 "{a.name}: plus operator"
    chck (a.zero - a.one == -a.one)                                "{a.name}: minus operator"
    chck (a.zero * a.one == a.zero)                                "{a.name}: product operator"
    chck (a.zero / a.one == a.zero)                                "{a.name}: division operator"

    # sqrt
    two := a.one + a.one
    chck (a.sqrt (two * two) - two < a.epsilon)                    "{a.name}: sqrt"

    # exponentation / logarithm
    chck (a.exp(a.zero)  == a.one)                                 "{a.name}: exp"
    chck (a.log(a.one)   == a.zero)                                "{a.name}: log"

    # trigonometric
    chck (a.sin(a.zero)  == a.zero)                                "{a.name}: sin"
    chck (a.cos(a.zero)  == a.one)                                 "{a.name}: cos"
    chck (a.tan(a.zero)  == a.zero)                                "{a.name}: tan"
    chck (a.asin(a.zero) == a.zero)                                "{a.name}: asin"
    chck (a.acos(a.one)  == a.zero)                                "{a.name}: acos"
    chck (a.atan(a.zero) == a.zero)                                "{a.name}: atan"

    # hyperbolicus
    chck (a.sinh(a.zero)  == a.zero)                               "{a.name}: sinh"
    chck (a.cosh(a.zero)  == a.one)                                "{a.name}: cosh"
    chck (a.tanh(a.zero)  == a.zero)                               "{a.name}: tanh"
    # NYI arcos hyperbolicus
    # chck (a.asinh(a.zero) == a.zero)                               "{a.name}: asinh"
    # chck (a.acosh(a.one)  == a.zero)                               "{a.name}: acosh"
    # chck (a.atanh(a.zero) == a.zero)                               "{a.name}: atanh"

  generic_tests f32s.zero
  generic_tests f64s.zero

  chck (f32s.min == 0x1P-126)                                      "f32s: min"
  chck (f32s.max == (f32 0x1P127 * (f32 2.0 - f32 0x1P-23)))       "f32s: max"
  chck (f32s.minExp == -126)                                       "f32s: minExp"
  chck (f32s.maxExp ==  127)                                       "f32s: maxExp"

  chck (f64s.min == 0x1P-1022)                                     "f64s: min"
  chck (f64s.max == (f64 0x1P1023 * (f64 2.0 - f64 0x1P-52)))      "f64s: max"
  chck (f64s.minExp == -1022)                                      "f64s: minExp"
  chck (f64s.maxExp ==  1023)                                      "f64s: maxExp"

  # power
  chck (f32 10.0 ** f32 2.0 == f32 100.0)                         "f32: 10 to the power 2 equals 100"
  chck (10.0 ** 2.0 == 100.0)                                     "f64: 10 to the power 2 equals 100"

  # modulo
  chck (f32 10.0 % f32 2.4 - f32 0.4 < f32 10.0 * f32s.epsilon)   "f32: 10 mod 2.4 is ~0.4"
  chck (10.0 % 2.4 - 0.4 <=10.0 * f64s.epsilon)                   "f64: 10 mod 2.4 is ~0.4"

  # castTo_f64, zero, negInf, posInf
  chck ((u64 0x_8000_0000_0000_0000).castTo_f64 == (-f64s.zero))                 "castTo_f64 works, bit representation for zero is correct"
  chck ((u64 0x_FFF0_0000_0000_0000).castTo_f64 == (f64s.negativeInfinity))      "castTo_f64 works, bit representation for negInf is correct"
  chck ((u64 0x_7FF0_0000_0000_0000).castTo_f64 == (f64s.positiveInfinity))      "castTo_f64 works, bit representation for posInf is correct"

  # castTo_u64
  chck ((-f64s.zero).castTo_u64 == 0x_8000_0000_0000_0000)                       "castTo_u64 works"
  chck ((f64s.negativeInfinity).castTo_u64 == 0x_FFF0_0000_0000_0000)            "castTo_u64 works"
  chck ((f64s.positiveInfinity).castTo_u64 == 0x_7FF0_0000_0000_0000)            "castTo_u64 works"

  # as_f64
  chck (i32s.one.as_f64 == 1.0)                                                  "i32s.as_f64 one"
  chck (u32s.one.as_f64 == 1.0)                                                  "u32s.as_f64 one"
  chck (i64s.one.as_f64 == 1.0)                                                  "i64s.as_f64 one"
  chck (u64s.one.as_f64 == 1.0)                                                  "u64s.as_f64 one"
  chck (i32s.zero.as_f64 == 0.0)                                                 "i32s.as_f64 zero"
  chck (u32s.zero.as_f64 == 0.0)                                                 "u32s.as_f64 zero"
  chck (i64s.zero.as_f64 == 0.0)                                                 "i64s.as_f64 zero"
  chck (u64s.zero.as_f64 == 0.0)                                                 "u64s.as_f64 zero"
  chck (i32s.min.as_f64 == -0x_8000_0000)                                        "i32s.as_f64 min"
  chck (i64s.min.as_f64 == -0x_8000_0000_0000_0000)                              "i64s.as_f64 min"
  chck (i32s.max.as_f64 == 0x_7fff_ffff)                                         "i32s.as_f64 max"
  chck (i64s.max.as_f64 == 0x8000_0000_0000_00C0)                                "i64s.as_f64 max"
  chck (u32s.max.as_f64 == 0x_ffff_ffff)                                         "u32s.as_f64 max"
  chck (u64s.max.as_f64 == 0x_ffff_ffff_ffff_ffff)                               "u64s.as_f64 max"
  chck ((f32 1.5).as_f64 == 1.5)                                                 "f32.as_f64 1.5"

  # check some corner case numbers for correct bit representation
  chck ((f32 0x1P-149)        == (u32 0x00000001).castTo_f32)                    "f32: smallest positive subnormal number"
  chck ((f32 0x0.FFFFFEP-126) == (u32 0x007FFFFF).castTo_f32)                    "f32: largest subnormal number"
  chck ((f32 0x1P-126)        == (u32 0x00800000).castTo_f32)                    "f32: smallest positive normal"
  chck ((f32 0x1.FFFFFEP127)  == (u32 0x7F7FFFFF).castTo_f32)                    "f32: largest normal number"
  chck ((f32 1)-(f32 0x1P-24) == (u32 0x3F7FFFFF).castTo_f32)                    "f32: largest normal less than one"
  chck ((f32 1)+(f32 0x1P-23) == (u32 0x3F800001).castTo_f32)                    "f32: smallest number larger one"

  chck ((f32 0x0.3F4243P-126) == (u32 0x001FA122).castTo_f32)                    "f32: random subnormal"
  chck ((f32 0x0.7FFFFFP-126) == (u32 0x00400000).castTo_f32)                    "f32: subnormal rounded up"
  chck ((f32 0x1.7FFFFEP-126) == (u32 0x00BFFFFF).castTo_f32)                    "f32: random normal number"

  chck (f32 0x0.000006P-126  == (u32 0b0000_0000_0000_0000_0000_0011).castTo_f32) "f32: no rounding necessaryy"
  chck (f32 0x0.7FFFF9P-126  == (u32 0b0011_1111_1111_1111_1111_1100).castTo_f32) "f32: subnormal rounded down"
  chck (f32 0x0.7FFFF91P-126 == (u32 0b0011_1111_1111_1111_1111_1101).castTo_f32) "f32: subnormal rounded up"
  chck (f32 0x0.000006P-126 + 0x0.7FFFF9P-126 == (u32 0b0011_1111_1111_1111_1111_1111).castTo_f32) "f32: addition"

  # real:       0b0111_1111_1111_1111_1111_1111
  # rounded:    0b1000_0000_0000_0000_0000_0000
  chck (f32 0x0.7FFFFFP-126 == (u32 0b0100_0000_0000_0000_0000_0000).castTo_f32) "f32: rounded up"

  fuzion.std.exit exitCode
